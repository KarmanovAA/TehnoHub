#include "stdafx.h"
#include <iostream>

using namespace std;

class ArrayWrapper {
	int *arr_;
	int size_;
public:
	ArrayWrapper(int size = 0) : size_(size), arr_(new int[size_]) {};
	ArrayWrapper(int size, int* arr);
	ArrayWrapper(const ArrayWrapper&);
	~ArrayWrapper();
	ArrayWrapper& operator= (const ArrayWrapper&);
	int get_size() const;
	int& operator[] (const int& index);
	bool operator== (const ArrayWrapper&) const;
	ArrayWrapper& operator+ (const ArrayWrapper&) const;
	ArrayWrapper& operator+= (const ArrayWrapper&);
	friend ostream& operator<< (std::ostream&, const ArrayWrapper&);
};

int ArrayWrapper::get_size() const{
	return size_;
}

ostream& operator<<(std::ostream& output, const ArrayWrapper& a) {
	for (int i = 0; i < ArrayWrapper.get_size(); i++)
		output << a[i] << endl;
	return output;
}

ArrayWrapper::ArrayWrapper(int size, int* arr) {
	size_ = size;
	arr_ = new int[size_];
	for (int i = 0; i < size; i++)
		arr_[i] = arr[i];
}
ArrayWrapper::ArrayWrapper(const ArrayWrapper& ir) {
	size_ = ir.size_;
	arr_ = new int[size_];
	for (int i = 0; i < size_; i++)
		arr_[i] = ir.arr_[i];
}
ArrayWrapper::~ArrayWrapper() {
	size_ = 0;
	delete[]arr_;
}
ArrayWrapper& ArrayWrapper::operator= (const ArrayWrapper& rhs) {
	if (arr_ = 0)
		arr_ = new int[rhs.size_];
	size_ = rhs.size_;
	for (int i = 0; i < size_; i++)
		arr_[i] = rhs.arr_[i];
}
int& ArrayWrapper::operator[] (const int& index) {
	if (index >= size_)
		cerr << "out of range";
	return arr_[index];
}
bool ArrayWrapper::operator== (const ArrayWrapper& comp) const {
	if (size_ != comp.size_)
		return 0;
	else {
		for (int i = 0; i < size_; i++) {
			if (arr_[i] != comp.arr_[i])
				return 0;
		}
		return 1;
	}
}
ArrayWrapper& ArrayWrapper::operator+(const ArrayWrapper& rhs) const {
	ArrayWrapper res(size_, arr_);
	res.size_ = rhs.size_ + size_;
	for (int i = size_; i < res.size_; i++) {
		res.arr_[i] = 
	}
	return res;
}
